---
title: "Anti-Reverse"
classes: wide
header:
  teaser: /assets/images/malware-analysis/Vidar/logo.jpg
ribbon: DodgerBlue
description: "Anti-debugging,Anti-Disassembly"
categories:
  - Malware Analysis
toc: true
---

#  Anti-Disassembly from practical malware analysis

#### ⦁	Understanding Anti-Disassembly.

​			first thing we need to know what is anti-disassembly. anti-disassembly: is a Technique that makes 			disassembly difficult for a malware analyst the malware writer use this Techniques. 

#### ⦁	Defeating Disassembly Algorithms.

###### 		there are two type to disassembly 

1. Linear Disassembly: this type is iterates over a block of code, disassembling one instruction at a 		time linearly, without regard for flow-control instructions, this basic strategy.

2. Flow-Oriented Disassembly: A more advanced strategy this method used by most commercial disassemblers this type determines and examines  the instructions and builds a list of locations like “JZ” this instruction like “if statement” by this strategy the disassemblers can disassemble false first and put the location for true in the list to disassemble in the future

   

#### ⦁	 Anti-Disassembly Techniques. 

1. ##### 			Jump Instructions with the Same:

​					Target this technique is a combination of “JZ” with “JNZ”  In fact this is  an unconditional ”JMP“ 					but the disassembler doesn’t  recognize it 

​					![](/assets/images/malware-analysis/practical-malware/anti1.PNG)

​					When you see this  order , this is your first indication that anti-disassembly, you can see the 					opcode like this 

​					

​					![](/assets\images\malware-analysis\practical-malware\anti2.PNG)

​					You  need to understand the opcode in first 4 byte you can see “JZ” and “JNZ” instructions and 					then “CALL“ instruction the problem in “CALL” instruction .you can patch it by “NOP” = “0x90” or 					convert it from code to data like this 

​					![](/assets/images/malware-analysis/practical-malware/anti3.PNG)

​	

 2. **A Jump Instruction with a Constant Condition :** this technique is a commen one they use conditional jump every time will be true 

    ​			![](/assets/images/malware-analysis/practical-malware/anti4.PNG)

    ​			In this example the “XOR” instruction put zero in eax and every time the condition will be ture 			The problem is happening when the disassembler disassembles the false first and by this it will 			conflict with the “0xE9” instruction and disassemble it to “JMP” to location Depends on the next 4 			byte you can solve this problem by converting “0xE9” to data not code like this .

    ​			![](/assets/images/malware-analysis/practical-malware/anti5.PNG)

    

3. **Impossible Disassembly :** this term does not mean written but the difference  is in the previous sections we could to know the technique by read instructions now in this technique uses byte that we can’t ignored this mean we can’t only replace this byte with “0x90” = “NOP” . in this example you can see “0xFF” is a part of both instructions 

​					![](/assets/images/malware-analysis/practical-malware/anti6.PNG)

​		You can notice that the “EAX ” inc then dec to solve this problem you can convert all byte to data you 		can see this sequence of byte doesn't make error in disassembly but makes wrong result so we call 		this Impossible Disassembly

## Note

so you see we use “NOP” in a lot of bytes, so we can use plugin written in python with IDA PRO to entire the first byte and the last byte and it will full it by “NOP” instruction .

![](/assets/images/malware-analysis/practical-malware/anti7.PNG)
[^note]:testtttttttt
